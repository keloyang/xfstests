#
# overlayfs specific common functions.
#
. ./common/module

# helper function to do the actual overlayfs mount operation
_overlay_mount_dirs()
{
	local lowerdir=$1
	local upperdir=$2
	local workdir=$3
	shift 3

	$MOUNT_PROG -t overlay -o lowerdir=$lowerdir -o upperdir=$upperdir \
		    -o workdir=$workdir `_common_dev_mount_options $*`
}

# Mount with same options/mnt/dev of scratch mount, but optionally
# with different lower/upper/work dirs
_overlay_scratch_mount_dirs()
{
	local lowerdir=$1
	local upperdir=$2
	local workdir=$3
	shift 3

	_overlay_mount_dirs $lowerdir $upperdir $workdir \
				$* $OVL_BASE_SCRATCH_MNT $SCRATCH_MNT
}

_overlay_mkdirs()
{
	local dir=$1

	mkdir -p $dir/$OVL_UPPER
	mkdir -p $dir/$OVL_LOWER
	mkdir -p $dir/$OVL_WORK
	mkdir -p $dir/$OVL_MNT
}

# Given a base fs dir, set up overlay directories and mount on the given mnt.
# The dir is used as the mount device so it can be seen from df or mount
_overlay_mount()
{
	local dir=$1
	local mnt=$2
	shift 2

	_supports_filetype $dir || _notrun "upper fs needs to support d_type"

	_overlay_mkdirs $dir

	_overlay_mount_dirs $dir/$OVL_LOWER $dir/$OVL_UPPER $dir/$OVL_WORK \
				$* $dir $mnt
}

_overlay_base_mount()
{
	local devname=$1
	local mntname=$2
	local dev=$3
	local mnt=$4
	shift 4

	if [ -z "$dev" -o -z "$mnt" ] || \
		_check_mounted_on $devname $dev $mntname $mnt; then
		# no base fs or already mounted
		return 0
	elif [ $? -ne 1 ]; then
		# base fs mounted but not on mount point
		return 1
	fi

	_mount $* $dev $mnt
}

_overlay_base_test_mount()
{
	_overlay_base_mount OVL_BASE_TEST_DEV OVL_BASE_TEST_DIR \
			"$OVL_BASE_TEST_DEV" "$OVL_BASE_TEST_DIR" \
			$TEST_FS_MOUNT_OPTS $SELINUX_MOUNT_OPTIONS
}

_overlay_test_mount()
{
	_overlay_base_test_mount && \
		_overlay_mount $OVL_BASE_TEST_DIR $TEST_DIR $*
}

_overlay_base_scratch_mount()
{
	_overlay_base_mount OVL_BASE_SCRATCH_DEV OVL_BASE_SCRATCH_MNT \
			"$OVL_BASE_SCRATCH_DEV" "$OVL_BASE_SCRATCH_MNT" \
			$OVL_BASE_MOUNT_OPTIONS $SELINUX_MOUNT_OPTIONS
}

_overlay_scratch_mount()
{
	_overlay_base_scratch_mount && \
		_overlay_mount $OVL_BASE_SCRATCH_MNT $SCRATCH_MNT $*
}

_overlay_base_unmount()
{
	local dev=$1
	local mnt=$2

	[ -n "$dev" -a -n "$mnt" ] || return 0

	$UMOUNT_PROG $mnt
}

_overlay_test_unmount()
{
	$UMOUNT_PROG $TEST_DIR
	_overlay_base_unmount "$OVL_BASE_TEST_DEV" "$OVL_BASE_TEST_DIR"
}

_overlay_scratch_unmount()
{
	$UMOUNT_PROG $SCRATCH_MNT
	_overlay_base_unmount "$OVL_BASE_SCRATCH_DEV" "$OVL_BASE_SCRATCH_MNT"
}

# Require a specific overlayfs feature
_require_scratch_overlay_feature()
{
	local feature=$1

	# overalyfs features (e.g. redirect_dir, index) are
	# configurable from Kconfig (the build default), by module
	# parameter (the system default) and per mount by mount
	# option ${feature}=[on|off].
	#
	# If the module parameter does not exist then there is no
	# point in checking the mount option.
	local default=`_get_fs_module_param ${feature}`
	[ "$default" = Y ] || [ "$default" = N ] || \
		_notrun "feature '${feature}' not supported by ${FSTYP}"

	_scratch_mkfs > /dev/null 2>&1
	_scratch_mount -o ${feature}=on || \
		_notrun "${FSTYP} feature '${feature}' cannot be enabled on ${SCRATCH_DEV}"
	# Check options to be sure. For example, Overlayfs will fallback to
	# index=off if underlying fs does not support file handles.
	# Overlayfs only displays mount option if it differs from the default.
	# Overlayfs may enable the feature, but fallback to read-only mount.
	((( [ "$default" = N ] && _fs_options $SCRATCH_DEV | grep -q "${feature}=on" ) || \
	  ( [ "$default" = Y ] && ! _fs_options $SCRATCH_DEV | grep -q "${feature}=off" )) && \
	    touch $SCRATCH_MNT/foo 2>/dev/null ) || \
	        _notrun "${FSTYP} feature '${feature}' cannot be enabled on ${SCRATCH_DEV}"
	_scratch_unmount
}

# Basic sanity checks for overlayfs
_overlay_check_dirs()
{
	local lowerdir=$1
	local upperdir=$2
	local workdir=$3
	local err=0

	# If 'work' dir exists, it should be empty except for features directories
	lswork=`find $workdir/work -mindepth 1 -name '*_features' -prune -o -print 2>/dev/null`
	if [ -n "$lswork" ]; then
		_log_err "_overlay_check_dirs: work dir is not clean"
		echo "*** list $workdir/work ***"	>>$seqres.full
		ls -l $workdir/work 2>/dev/null		>>$seqres.full
		echo "*** end list $workdir/work"	>>$seqres.full
		err=1
	fi

	# If 'index' dir exists, it should contain valid index names and features directories
	lsindex=`find $workdir/index -mindepth 1 -name '*_features' -prune -o -name '00fb*' -o -print 2>/dev/null`
	if [ -n "$lsindex" ]; then
		_log_err "_overlay_check_dirs: index dir is not clean"
		echo "*** list $workdir/index ***"	>>$seqres.full
		ls -l $workdir/index 2>/dev/null	>>$seqres.full
		echo "*** end list $workdir/index"	>>$seqres.full
		err=1
	fi

	# Index should not contain entries of file types that do not exist
	# in niether lower nor upper dir. For example, if upper or lower
	# do not contain symlinks, index should not contain symlinks entries.
	# To simplify, we do not check chardevs, which could be upper
	# whiteouts or whiteout index entries.
	for t in f d b p l s; do
		# Skip all checks if index is disabled or empty
		# for example, in generic scratch tests
		[ -d $workdir/index ] || break
		local lsindex=`ls $workdir/index`
		[ -n "$lsindex" ] || break
		# Skip index features directories
		lsindex=`find $workdir/index -mindepth 1 -name '*_features' -prune -o -type $t -print`
		[ -n "$lsindex" ] || continue
		local lslower=""
		# For directories, upper dirs must exist if index
		# entries exist, so we ignore lower entries
		[ $t = d ] || \
			lslower=`find $lowerdir -mindepth 1 -type $t`
		local lsupper=""
		[ -n "$lslower" ] || \
			lsupper=`find $upperdir -mindepth 1 -type $t`
		# Index entry found, but no upper nor lower entry?
		[ -z "$lslower" -a -z "$lsupper" ] || continue

		_log_err "_overlay_check_dirs: index dir has stale entry of type $t"
		echo "*** list $workdir/index ***"	>>$seqres.full
		ls -l $workdir/index 2>/dev/null	>>$seqres.full
		$GETFATTR_PROG --absolute-names -e hex -m overlay -d -h \
			$workdir/index/* 2>/dev/null	>>$seqres.full
		echo "*** end list $workdir/index"	>>$seqres.full
		err=1
		break
	done

	if [ $err != 0 ]; then
		status=1
		if [ "$iam" != "check" ]; then
			exit 1
		fi
		return 1
	fi

	return 0
}

_overlay_check_fs()
{
	local base_dev=$3
	local base_mnt=$4

	[ "$FSTYP" = overlay ] || return 0

	# Base fs needs to be mounted to check overlay dirs
	local mounted=""
	[ -z "$base_dev" ] || mounted=`_is_mounted $base_dev`
	[ -n "$mounted" ] || _overlay_base_mount $*

	# No need to umount overlay for dir checks
	_overlay_check_dirs $base_mnt/$OVL_LOWER $base_mnt/$OVL_UPPER \
			    $base_mnt/$OVL_WORK
	local ret=$?

	[ -n "$mounted" ] || _overlay_base_unmount "$base_dev" "$base_mnt"
	return $ret
}

_check_overlay_test_fs()
{
	_overlay_check_fs OVL_BASE_TEST_DEV OVL_BASE_TEST_DIR \
			"$OVL_BASE_TEST_DEV" "$OVL_BASE_TEST_DIR" \
			$TEST_FS_MOUNT_OPTS $SELINUX_MOUNT_OPTIONS
}

_check_overlay_scratch_fs()
{
	_overlay_check_fs OVL_BASE_SCRATCH_DEV OVL_BASE_SCRATCH_MNT \
			"$OVL_BASE_SCRATCH_DEV" "$OVL_BASE_SCRATCH_MNT" \
			$OVL_BASE_MOUNT_OPTIONS $SELINUX_MOUNT_OPTIONS
}
